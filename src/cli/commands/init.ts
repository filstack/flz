import chalk from 'chalk';
import path from 'path';
import { runWizard } from '../wizard/prompts.js';
import { installSkills } from '../../core/installer.js';
import { saveConfig, configExists, loadConfig, getCurrentVersion, type AgentInstallation } from '../../core/config.js';
import { configureMcp, getMcpInstructions } from '../../core/mcp.js';
import { getAgentConfig } from '../../core/agents.js';
import { getTransformer } from '../../core/transformer.js';
import { WORKFLOW_SKILLS } from '../../core/transformer.js';
import { fileExists, removeDirectory, removeFile } from '../../utils/fs.js';

async function removeAgentSetup(projectDir: string, agent: AgentInstallation): Promise<void> {
  const agentConfig = getAgentConfig(agent.id);

  await removeDirectory(path.join(projectDir, agent.skillsDir));

  if (agent.id === 'antigravity') {
    const workflowsDir = path.join(projectDir, agentConfig.configDir, 'workflows');
    for (const workflow of WORKFLOW_SKILLS) {
      const workflowFile = path.join(workflowsDir, `${workflow}.md`);
      if (await fileExists(workflowFile)) {
        await removeFile(workflowFile);
      }
    }

    for (const ruleFile of ['ai-factory-guardrails.md', 'ai-factory-conventions.md']) {
      const rulePath = path.join(projectDir, agentConfig.configDir, 'rules', ruleFile);
      if (await fileExists(rulePath)) {
        await removeFile(rulePath);
      }
    }
  }

  // Keep agent settings file intact: it may contain user-managed configuration
  // unrelated to AI Factory.
}

export async function initCommand(): Promise<void> {
  const projectDir = process.cwd();

  console.log(chalk.bold.blue('\nðŸ­ AI Factory - Project Setup\n'));

  const hasExistingConfig = await configExists(projectDir);
  const existingConfig = hasExistingConfig ? await loadConfig(projectDir) : null;

  if (hasExistingConfig) {
    console.log(chalk.yellow('Warning: .ai-factory.json already exists.'));
    console.log('Running init will reconfigure selected agents (add/remove) and reinstall base skills.\n');
  }

  try {
    const existingAgentIds = existingConfig?.agents.map(agent => agent.id) ?? [];
    const answers = await runWizard(projectDir, existingAgentIds);

    const selectedAgentIds = new Set(answers.agents.map(agent => agent.id));
    const removedAgents = (existingConfig?.agents ?? []).filter(agent => !selectedAgentIds.has(agent.id));

    if (removedAgents.length > 0) {
      console.log(chalk.dim('\nRemoving deselected agent setups...\n'));
      for (const removedAgent of removedAgents) {
        await removeAgentSetup(projectDir, removedAgent);
        console.log(chalk.yellow(`  Removed: ${removedAgent.id}`));
      }
    }

    console.log(chalk.dim('\nInstalling skills...\n'));

    const installedAgents: AgentInstallation[] = [];
    const mcpSummary: Record<string, string[]> = {};

    for (const agentSelection of answers.agents) {
      const agentConfig = getAgentConfig(agentSelection.id);

      const installedSkills = await installSkills({
        projectDir,
        skillsDir: agentConfig.skillsDir,
        skills: answers.selectedSkills,
        stack: null, // Stack-specific skills generated by /ai-factory in Claude
        agentId: agentSelection.id,
      });

      const configuredMcp = await configureMcp(projectDir, {
        github: agentSelection.mcpGithub,
        filesystem: agentSelection.mcpFilesystem,
        postgres: agentSelection.mcpPostgres,
        chromeDevtools: agentSelection.mcpChromeDevtools,
      }, agentSelection.id);

      if (configuredMcp.length > 0) {
        mcpSummary[agentSelection.id] = configuredMcp;
      }

      installedAgents.push({
        id: agentSelection.id,
        skillsDir: agentConfig.skillsDir,
        installedSkills,
        mcp: {
          github: agentSelection.mcpGithub,
          filesystem: agentSelection.mcpFilesystem,
          postgres: agentSelection.mcpPostgres,
          chromeDevtools: agentSelection.mcpChromeDevtools,
        },
      });
    }

    await saveConfig(projectDir, {
      version: getCurrentVersion(),
      agents: installedAgents,
    });

    console.log(chalk.green('âœ“ Configuration saved to .ai-factory.json'));

    console.log(chalk.bold.green('\nâœ… Setup complete!\n'));

    for (const agent of installedAgents) {
      const agentConfig = getAgentConfig(agent.id);

      console.log(chalk.bold(`${agentConfig.displayName}:`));
      console.log(chalk.dim(`  Skills directory: ${path.join(projectDir, agent.skillsDir)}`));
      console.log(chalk.dim(`  Installed skills: ${agent.installedSkills.length}`));

      const configuredMcp = mcpSummary[agent.id];
      if (configuredMcp && configuredMcp.length > 0) {
        console.log(chalk.green(`  MCP servers configured: ${configuredMcp.join(', ')}`));
        const instructions = getMcpInstructions(configuredMcp);
        for (const instruction of instructions) {
          console.log(chalk.dim(`    ${instruction}`));
        }
      }
      console.log('');
    }

    console.log(chalk.bold('\nNext steps:'));

    for (const [index, agent] of installedAgents.entries()) {
      const agentConfig = getAgentConfig(agent.id);
      const transformer = getTransformer(agent.id);
      const welcomeMessage = transformer.getWelcomeMessage?.();

      console.log(chalk.dim(`  ${index + 1}. ${agentConfig.displayName}`));
      if (welcomeMessage) {
        for (const line of welcomeMessage) {
          console.log(chalk.dim(`     ${line}`));
        }
      } else {
        console.log(chalk.dim('     Open the agent in this directory'));
        console.log(chalk.dim('     Run /ai-factory to analyze project and generate stack-specific skills'));
      }
    }
    console.log(chalk.dim(`  ${installedAgents.length + 1}. Use /ai-factory-plan and /ai-factory-commit for daily workflow`));
    console.log('');

  } catch (error) {
    if ((error as Error).message?.includes('User force closed')) {
      console.log(chalk.yellow('\nSetup cancelled.'));
      return;
    }
    throw error;
  }
}
